(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{261:function(v,_,e){"use strict";e.r(_);var t=e(2),o=Object(t.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"csrf-攻击原理以及防范"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#csrf-攻击原理以及防范"}},[v._v("#")]),v._v(" csrf 攻击原理以及防范")]),v._v(" "),e("p",[e("code",[v._v("CSRF（Cross-site request forgery）")]),v._v("，中文名称：跨站请求伪造，攻击者盗用了你的身份，以你的名义发送恶意请求。导致个人隐私泄露以及财产安全。")]),v._v(" "),e("h2",{attrs:{id:"攻击原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#攻击原理"}},[v._v("#")]),v._v(" 攻击原理")]),v._v(" "),e("p",[v._v("在网络层面要完成一次 "),e("code",[v._v("CSRF")]),v._v(" 攻击，受害者必须依次完成两个步骤：")]),v._v(" "),e("ol",[e("li",[v._v("登录受信任网站 A，并在本地生成 "),e("code",[v._v("Cookie。")])]),v._v(" "),e("li",[v._v("在不登出 A 的情况下，访问危险网站 B。")]),v._v(" "),e("li",[v._v("B 携带着 A 的 "),e("code",[v._v("Cookie")]),v._v(" 信息访问服务端")])]),v._v(" "),e("p",[v._v("这时候服务器并不能区分 B 的访问是非法的。")]),v._v(" "),e("h2",{attrs:{id:"csrf-防御"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#csrf-防御"}},[v._v("#")]),v._v(" CSRF 防御")]),v._v(" "),e("h3",{attrs:{id:"验证-http-referer-字段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#验证-http-referer-字段"}},[v._v("#")]),v._v(" 验证 HTTP Referer 字段")]),v._v(" "),e("p",[v._v("根据 "),e("code",[v._v("HTTP")]),v._v(" 协议，在 "),e("code",[v._v("HTTP")]),v._v(" 头中有一个字段叫 "),e("code",[v._v("Referer")]),v._v("，它记录了该 "),e("code",[v._v("HTTP")]),v._v(" 请求的来源地址。如果 "),e("code",[v._v("Referer")]),v._v(" 开头的域名是自己的网站，则说明该请求是来自银行网站自己的请求，是合法的。如果 "),e("code",[v._v("Referer")]),v._v(" 是其他网站的话，则有可能是黑客的 "),e("code",[v._v("CSRF")]),v._v(" 攻击，拒绝该请求。")]),v._v(" "),e("p",[v._v("这种方式如果在前后端分离的情况下就不太合适，特别是牵涉到第三方应用的场景。")]),v._v(" "),e("p",[v._v("前后端分离一般是设置反向代理。有时候可能突然更改了前端服务地址，这时候验证 "),e("code",[v._v("Referer")]),v._v(" 就会失败。")]),v._v(" "),e("p",[v._v("第三方应用会很多，也可能会随时更改服务地址。而且第三方服务还会牵涉到跨域的问题，"),e("code",[v._v("这里跨域建议开启白名单策略，不能所有的接口请求都接受")])]),v._v(" "),e("h3",{attrs:{id:"在请求地址中添加-token-并验证"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#在请求地址中添加-token-并验证"}},[v._v("#")]),v._v(" 在请求地址中添加 token 并验证")]),v._v(" "),e("p",[v._v("可以在 "),e("code",[v._v("HTTP")]),v._v(" 请求中以参数的形式加入一个随机产生的 "),e("code",[v._v("token")]),v._v("，并在服务器端建立一个拦截器来验证这个 "),e("code",[v._v("token")]),v._v("，如果请求中没有 "),e("code",[v._v("token")]),v._v(" 或者 "),e("code",[v._v("token")]),v._v(" 内容不正确，则认为可能是 "),e("code",[v._v("CSRF")]),v._v(" 攻击而拒绝该请求。")]),v._v(" "),e("p",[e("code",[v._v("公司的漏扫工具就是基于这个原理来扫描的")]),v._v("。所以要在 form 表单里加一个隐藏 input")]),v._v(" "),e("h3",{attrs:{id:"在-http-头中自定义属性并验证"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#在-http-头中自定义属性并验证"}},[v._v("#")]),v._v(" 在 HTTP 头中自定义属性并验证")]),v._v(" "),e("p",[v._v("这种方法也是使用 "),e("code",[v._v("token")]),v._v(" 并进行验证，和上一种方法不同的是，这里并不是把 "),e("code",[v._v("token")]),v._v(" 以参数的形式置于 "),e("code",[v._v("HTTP")]),v._v(" 请求之中，而是把它放到 "),e("code",[v._v("HTTP")]),v._v(" 头中自定义的属性里。")]),v._v(" "),e("p",[e("code",[v._v("目前研发开发的服务都是基于这个方式")])]),v._v(" "),e("p",[v._v("以上方式基本解决了在网页端的防范，但是还有情况就是通过抓包获取到了你的 "),e("code",[v._v("token")]),v._v("，这时候依然可以使用。对于这种可以多加一些防范。")]),v._v(" "),e("ol",[e("li",[e("p",[e("code",[v._v("cookie")]),v._v(" + "),e("code",[v._v("token")]),v._v("，其中 cookie 设置为 "),e("code",[v._v("http-only")]),v._v("，防止客户端通过代码获取到")])]),v._v(" "),e("li",[e("p",[e("code",[v._v("token")]),v._v(" 二次加密")])]),v._v(" "),e("li",[e("p",[e("code",[v._v("https")]),v._v(" 校验证书，防止抓包。")])]),v._v(" "),e("li",[e("p",[v._v("对接口进行请求参数签名（推荐）")]),v._v(" "),e("p",[v._v("以上方式也可以结合使用")])])]),v._v(" "),e("p",[v._v("当然在浏览器端绝对的安全没有，我们只能尽量防范。防止网站信息泄露，如果攻击者连网站都不知道，肯定就攻击不到了。")]),v._v(" "),e("p",[v._v("服务端还可以做一些敏感行为，例如 平常都是在 河南某个地址，突然又一天在 安徽某个地址访问了，就可以推送用户告警。")]),v._v(" "),e("p",[v._v("不像客户端，客户端甚至可以和设备绑定，即便你账号密码都正确，设备不正确都不能登录。")])])}),[],!1,null,null,null);_.default=o.exports}}]);